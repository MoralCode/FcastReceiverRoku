namespace protocol

	const headerLength = 5

	enum Opcode
		play = 1
		pause
		resume
		stop
		seek
		playbackUpdate
		volumeUpdate
		setVolume
		playbackError
		setSpeed
		version
		ping
		pong
		initial
		playUpdate
		setPlaylistItem
		subscribeEvent
		unsubscribeEvent
		event
	end enum

	class FCastMessage

		sub new(opcode as protocol.Opcode, payload as object)
			m.opcode = opcode
			m.payload = payload <> invalid ? protocol.CleanPayload(payload): invalid
		end sub
		
		opcode as protocol.Opcode
		payload as object

		sub toBytes(buffer as object, bufferSize as integer)
			payloadData = invalid

			payloadBuffer = CreateObject("roByteArray")
			payloadBuffer[2048] = 0

			if m.payload <> invalid then
				payloadDataArray = protocol.CleanPayload(m.payload)

				' if m.payload <> invalid then
				payloadData = FormatJson(payloadDataArray)
				' end if
				payloadBuffer.FromAsciiString(payloadData)

			end if

			packetLength = 1 ' default, for just the opcode

			if payloadData <> invalid then
				packetLength = packetLength + Len(payloadData)
				for x = 0 to packetLength - 1 - 1
					buffer[5 + x] = payloadBuffer[x]
				end for
				buffer[5 + packetLength - 1] = 0
			end if
			buffer[0] = (packetLength and &HFF)
			buffer[1] = (packetLength >> 8) and &HFF
			buffer[2] = (packetLength >> 16) and &HFF
			buffer[3] = (packetLength >> 24) and &HFF
			buffer[4] = m.opcode
		end sub

		sub contentLength() as integer
			return  Len(FormatJson(CleanPayload(m.payload)))
		end sub

		sub byteLength() as integer
			return 5 + Len(FormatJson(CleanPayload(m.payload)))
		end sub
	end class

	function CleanPayload(incomingPayload as object) as object
		payloadDataArray = {}
		' copy payload array from object without copying methods from that object
		if incomingPayload <> invalid then
			for each key in incomingPayload
				if type(incomingPayload[key]) <> "roFunction" then
					payloadDataArray[key] = incomingPayload[key]
				end if
			end for
		end if
		return payloadDataArray
	end function

	function DecodeBytes(bytes as object) as protocol.FCastMessage
		if bytes = invalid or bytes.count() < headerLength then return invalid

		' 1. Extract Length (First 4 bytes, Little Endian)
		' Index 0 is the lowest value, Index 3 is the highest value
		' Formula: byte0 + (byte1 << 8) + (byte2 << 16) + (byte3 << 24)
		packetLength = bytes[0] + (bytes[1] << 8) + (bytes[2] << 16) + (bytes[3] << 24)
		' opcode is the 5th byte
		opcode = bytes[4] as Opcode
		#if debug
		print `Detected Packet Length: ${packetLength} Opcode: ${opcode}`
		#end if
		' 2. Validation
		actualDataSize = bytes.count() - headerLength

		data = invalid

		if actualDataSize < packetLength - 1 then
			print "ERROR: Incomplete packet."
			#if debug
			print `Need ${packetLength} but got ${actualDataSize}`
			#end if
			return invalid
		else if actualDataSize > 0 then
			slice = bytes.Slice(headerLength, headerLength + packetLength)
			asciislice = slice.ToAsciiString()
			data = ParseJson(asciislice)
		end if

		if opcode = Opcode.play then
			data = data as PlayMessage
		else if opcode = Opcode.seek then
			data = data as SeekMessage
		else if opcode = Opcode.playbackUpdate then
			data = data as PlaybackUpdateMessage
		else if opcode = Opcode.volumeUpdate then
			data = data as VolumeUpdateMessage
		else if opcode = Opcode.setVolume then
			data = data as SetVolumeMessage
		else if opcode = Opcode.playbackError then
			data = data as PlaybackErrorMessage
		else if opcode = Opcode.setSpeed then
			data = data as SetSpeedMessage
		else if opcode = Opcode.setSpeed then
			data = data as SetSpeedMessage
		end if

		return new protocol.FCastMessage(opcode, data)
	end function

end namespace
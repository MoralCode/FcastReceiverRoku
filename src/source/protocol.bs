namespace protocol

	enum Opcode
		play = 1
		pause
		resume
		stop
		seek
		playbackUpdate
		volumeUpdate
		setVolume
		playbackError
		setSpeed
		version
		ping
		pong
		initial
		playUpdate
		setPlaylistItem
		subscribeEvent
		unsubscribeEvent
		event
	end enum

	enum PlaybackState
		idle
		playing
		paused
	end enum

	class FCastMessage

		sub new(opcode as protocol.Opcode, payload as object)
			m.opcode = opcode
			m.payload = payload
		end sub
		
		opcode as protocol.Opcode
		payload as object

		sub toBytes(buffer as object, bufferSize as integer)
			payloadData = invalid
			if m.payload <> invalid then
				payloadData = FormatJson
			end if

			packetLength = 1 ' default

			if payloadData <> invalid then
				packetLength = packetLength + Len(payloadData)
			end if
			buffer[0] = (packetLength and &HFF)
			buffer[1] = (packetLength >> 8) and &HFF
			buffer[2] = (packetLength >> 16) and &HFF
			buffer[3] = (packetLength >> 24) and &HFF
			buffer[4] = m.opcode

			for x = 0 to packetLength - 1
				buffer[5 + x] = payloadData[x]
			end for
			buffer[5+packetLength] = 0

			' return buffer

		end sub
	end class

	class PlayMessage
		container as string 'The MIME type (video/mp4)
		optional url as string 'The URL to load (optional)
		optional content as string 'The content to load (i.e. a DASH manifest, optional)
		optional starttime as integer' The time to start playing in seconds
	end class

	class SeekMessage
		time as integer 'The time to seek to in seconds
	end class

	class PlaybackUpdateMessage
		time as integer 'The current time playing in seconds
		state as protocol.PlaybackState 'The playback state
	end class

	class VolumeUpdateMessage
		volume as float 'The current volume (0-1)
	end class

	class SetVolumeMessage
		volume as float 'The desired volume (0-1)
	end class


	function DecodeBytes(bytes as object) as protocol.FCastMessage
		if bytes = invalid or bytes.count() < 5 then return invalid

		' 1. Extract Length (First 4 bytes, Little Endian)
		' Index 0 is the lowest value, Index 3 is the highest value
		' Formula: byte0 + (byte1 << 8) + (byte2 << 16) + (byte3 << 24)
		headerLength = 5

		packetLength = bytes[0] + (bytes[1] * 256) + (bytes[2] * 65536) + (bytes[3] * 16777216)
		' opcode is the 5th byte
		opcode = bytes[4]
		#if debug
		print "Detected Packet Length: "; packetLength
		#end if
		' 2. Validation
		actualDataSize = bytes.count() - headerLength

		data = invalid

		if actualDataSize < packetLength then
			print "ERROR: Incomplete packet."
			#if debug
			print "Need "; packetLength ; " but got "; actualDataSize
			#end if
			return invalid
		else if actualDataSize > 0 then
			slice = bytes.Slice(headerLength, headerLength + packetLength)
			asciislice = slice.ToAsciiString()
			data = ParseJson(asciislice)
		end if

		return new protocol.FCastMessage(opcode, data)
	end function

end namespace
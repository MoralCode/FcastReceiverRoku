namespace protocol

	enum Opcode
		play = 1
		pause
		resume
		stop
		seek
		playbackUpdate
		volumeUpdate
		setVolume
		playbackError
		setSpeed
		version
		ping
		pong
		initial
		playUpdate
		setPlaylistItem
		subscribeEvent
		unsubscribeEvent
		event
	end enum

	enum PlaybackState
		idle
		playing
		paused
	end enum

	class FCastMessage

		sub new(opcode as protocol.Opcode, payload as object)
			m.opcode = opcode
			m.payload = payload
		end sub
		
		opcode as protocol.Opcode
		payload as object

		sub toBytes(buffer as object, bufferSize as integer)
			payloadData = invalid
			if m.payload <> invalid then
				payloadData = FormatJson(m.payload)
			end if

			payloadBuffer = CreateObject("roByteArray")
			payloadBuffer[2048] = 0

			payloadBuffer.FromAsciiString(payloadData)

			packetLength = 1 ' default

			if payloadData <> invalid then
				packetLength = packetLength + Len(payloadData)
			end if
			buffer[0] = (packetLength and &HFF)
			buffer[1] = (packetLength >> 8) and &HFF
			buffer[2] = (packetLength >> 16) and &HFF
			buffer[3] = (packetLength >> 24) and &HFF
			buffer[4] = m.opcode
			for x = 0 to packetLength - 1 - 1
				buffer[5 + x] = payloadBuffer[x]
			end for
			buffer[5+packetLength - 1] = 0

			' return buffer

		end sub

		sub contentLength() as integer
			return  Len(FormatJson(m.payload))
		end sub

		sub byteLength() as integer
			return 5 + Len(FormatJson(m.payload))
		end sub
	end class

	class PlayMessage
		container as string 'The MIME type (video/mp4)
		optional url as string 'The URL to load (optional)
		optional content as string 'The content to load (i.e. a DASH manifest, optional)
		optional starttime as integer' The time to start playing in seconds
		optional speed as float 'The factor to multiply playback speed by (defaults to 1.0)
		optional headers as object 'HTTP request headers to add to the play request Map<string, string>
	end class

	class SeekMessage
		time as integer 'The time to seek to in seconds
	end class

	class PlaybackUpdateMessage
		time as integer 'The current time playing in seconds
		state as protocol.PlaybackState 'The playback state
		generationTime as integer 'The time the packet was generated (unix time milliseconds)
		duration as integer 'The duration in seconds
		optional speed as float ' The playback speed factor
	end class

	class VolumeUpdateMessage
		volume as float 'The current volume (0-1)
		generationTime as integer 'The time the packet was generated (unix time milliseconds)
	end class

	class SetVolumeMessage
		volume as float 'The desired volume (0-1)
	end class

	class SetSpeedMessage
		speed as float 'The factor to multiply playback speed by.
	end class

	class PlaybackErrorMessage
		message as string
	end class

	class VersionMessage
		version as integer
	end class

	function DecodeBytes(bytes as object) as protocol.FCastMessage
		if bytes = invalid or bytes.count() < 5 then return invalid

		' 1. Extract Length (First 4 bytes, Little Endian)
		' Index 0 is the lowest value, Index 3 is the highest value
		' Formula: byte0 + (byte1 << 8) + (byte2 << 16) + (byte3 << 24)
		headerLength = 5

		packetLength = bytes[0] + (bytes[1] << 8) + (bytes[2] << 16) + (bytes[3] << 24)
		' opcode is the 5th byte
		opcode = bytes[4]
		#if debug
		print "Detected Packet Length: "; packetLength
		#end if
		' 2. Validation
		actualDataSize = bytes.count() - headerLength

		data = invalid

		if actualDataSize < packetLength then
			print "ERROR: Incomplete packet."
			#if debug
			print "Need "; packetLength ; " but got "; actualDataSize
			#end if
			return invalid
		else if actualDataSize > 0 then
			slice = bytes.Slice(headerLength, headerLength + packetLength)
			asciislice = slice.ToAsciiString()
			data = ParseJson(asciislice)
		end if

		return new protocol.FCastMessage(opcode, data)
	end function

end namespace
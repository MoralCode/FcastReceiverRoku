import "pkg:/source/protocol/util.bs"
import "pkg:/source/protocol/v2.bs"
sub init()
	m.top.functionName = "listenToTcp"
end sub

class Connection
	socket as roStreamSocket
	buffer as roByteArray

	sub new(socket as roStreamSocket, buffer as roByteArray)
		m.socket = socket
		m.buffer = buffer
	end sub
end class

sub listenToTcp()
	' Create the TCP socket
	tcp = CreateObject("roStreamSocket")
	if tcp = invalid then
		print "ERROR: Failed to create socket."
		return
	end if

	' Map of ID -> { socket: roStreamSocket, buffer: roByteArray }
	connections = {} 

	' Create a message port to receive socket events
	port = CreateObject("roMessagePort")
	tcp.setMessagePort(port)

	' Setup the receiving address and bind to the specified port
	addr = CreateObject("roSocketAddress")
	addr.setAddress("0.0.0.0")
	addr.setPort(m.top.port)

	if not tcp.setAddress(addr) then
		print "ERROR: Could not set address."
		return
	end if

	if not tcp.eOK()
		print "Error creating listen socket"
		stop
	end if

	' Start listening (the '5' is the max backlog of connections)
	tcp.notifyReadable(true)
	tcp.listen(5)
	#if logging
	print `TCP Listener started on port: ${m.top.port}`
	#end if
	while true
		' Wait for an event (connection request or data)
		msg = wait(0, port)

		if type(msg) = "roSocketEvent"
			socketID = msg.GetSocketID()
			socketIdStr = socketID.ToStr()

			' If the event is on our main listener, accept the connection
			if socketID = tcp.getID() and tcp.isReadable()
				newConn = tcp.accept()
				if newConn <> invalid
					#if logging
					print "--- New Connection Established ---"
					#end if
					newConn.setMessagePort(port)
					newConn.notifyReadable(true)
					connections[newConn.getID().ToStr()] = Connection(newConn, CreateObject("roByteArray"))

					versionPacket = new protocol.FCastMessage(protocol.Opcode.version, protocol.v2.VersionMessage())

					sendOne(newconn, versionPacket)
				end if
			else if connections.DoesExist(socketIdStr)
				' Activity on an open connection
				state = connections[socketIdStr]
				conn = state.socket

				closed = False
				if conn.isReadable()
					tempBuf = CreateObject("roByteArray")
					tempBuf[2048] = 0 ' Pre-allocate
					receivedByteCount = conn.receive(tempBuf, 0, 2048)
					if receivedByteCount > 0
						#if debug
							print `received packet: ${tempBuf.Slice(5, receivedByteCount).ToAsciiString()}`
							print `full nonnull buffer contents: ${tempBuf.Slice(5).ToAsciiString()}`
						#end if 
						' tempBuf.resize(receivedByteCount)
						' actualData = tempBuf.Slice(0, receivedByteCount)
						state.buffer.append(tempBuf.Slice(0, receivedByteCount))
						
						' IMPORTANT: Loop to decode ALL packets currently in the buffer
						while state.buffer.count() > 0

							fcastPacket = protocol.DecodeBytes(state.buffer.Slice(0, receivedByteCount))
							if fcastPacket <> invalid then
								m.top.payload = fcastPacket
								
								consumed = fcastPacket.byteLength()
								state.buffer = state.buffer.Slice(consumed, state.buffer.count() - consumed)
							else
								' Incomplete packet, wait for more data
								exit while
							end if
						end while
					else if receivedByteCount = 0 ' client closed
						closed = True
					end if
				end if
				if closed or not conn.eOK()
					#if logging
						print `closing connection ${socketID}`
					#end if
					conn.close()
					connections.delete(socketIdStr)
				end if
			end if
		else 
			#if logging
			print "other event received"
			#end if
		end if
	end while
end sub

' send to a single socket (such as when replying). Creates a new buffer
sub sendOne(socket as roStreamSocket, message as protocol.FCastMessage)
	sendbuffer = CreateObject("roByteArray")
	sendbuffer[message.byteLength()+1] = 0

	message.toBytes(sendbuffer, message.byteLength())
	#if debug
		print `Sending packet (${message.opcode}): ${sendbuffer.Slice(protocol.headerLength).ToAsciiString()}`
	#end if

	socket.send(sendbuffer, 0, message.byteLength())
end sub

' Function to send the same message to all current connections. Creates a new buffer and reuses it for each message
sub sendAll(connections as object, message as protocol.FCastMessage)
	sendbuffer = CreateObject("roByteArray")
	sendbuffer[message.byteLength() + 1] = 0

	message.toBytes(sendbuffer, message.byteLength())
	
	for each key in connections
		thisConnection = connections[key]
		thisConnection.socket.send(sendbuffer, 0, message.byteLength())
	end for

end sub
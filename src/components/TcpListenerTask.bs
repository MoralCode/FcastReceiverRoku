import "pkg:/source/protocol/util.bs"
import "pkg:/source/protocol/v2.bs"
sub init()
	m.top.functionName = "listenToTcp"
end sub

sub listenToTcp()
	' Create the TCP socket
	tcp = CreateObject("roStreamSocket")
	if tcp = invalid then
		print "ERROR: Failed to create socket."
		return
	end if

	connections = {}

	bufferSize = 2048
	buffer = CreateObject("roByteArray")
	buffer[bufferSize] = 0

	' Create a message port to receive socket events
	port = CreateObject("roMessagePort")
	tcp.setMessagePort(port)

	' Setup the receiving address and bind to the specified port
	addr = CreateObject("roSocketAddress")
	addr.setAddress("0.0.0.0")
	addr.setPort(m.top.port)

	if not tcp.setAddress(addr) then
		print "ERROR: Could not set address."
		return
	end if

	if not tcp.eOK()
		print "Error creating listen socket"
		stop
	end if

	' Start listening (the '5' is the max backlog of connections)
	tcp.notifyReadable(true)
	tcp.listen(5)
	#if logging
	print `TCP Listener started on port: ${m.top.port}`
	#end if
	while true
		' Wait for an event (connection request or data)
		msg = wait(0, port)

		if type(msg) = "roSocketEvent"
			socketID = msg.GetSocketID()

			' If the event is on our main listener, accept the connection
			if socketID = tcp.getID() and tcp.isReadable()
				newConn = tcp.accept()
				if newConn <> invalid
					#if logging
					print "--- New Connection Established ---"
					#end if
					newConn.setMessagePort(port)
					newConn.notifyReadable(true)
					connections[Stri(newConn.getID())] = newConn

					sendbuffer = CreateObject("roByteArray")
					sendbuffer[512] = 0
					versionPacket = new protocol.FCastMessage(protocol.Opcode.version, protocol.v2.VersionMessage())
					versionPacket.toBytes(sendbuffer, 512)
					sl = sendbuffer.Slice(5)
					print `Sending version: ${sl.ToAsciiString()}`

					newConn.send(sendbuffer, 0, versionPacket.byteLength())
				end if
			else
				' Activity on an open connection
				connection = connections[Stri(socketID)]
				closed = False
				if connection.isReadable()
					receivedByteCount = connection.receive(buffer, 0, bufferSize)
					if receivedByteCount > 0
						' print ByteArrayToHex(buffer)
						fcastPacket = protocol.DecodeBytes(buffer)
						if fcastPacket <> invalid then
							m.top.payload = fcastPacket

						end if
						buffer.clear()
					else if receivedByteCount = 0 ' client closed
						closed = True
					end if
				end if
				if closed or not connection.eOK()
					print `closing connection ${socketID}`
					connection.close()
					connections.delete(Stri(socketID))
				end if
			end if
		else 
			#if logging
			print "other event received"
			#end if
		end if
	end while
end sub
import "pkg:/source/utils/NetworkUtils.bs"
import "pkg:/source/utils/utils.bs"

sub init()

	m.player = m.top.findNode("videoPlayback")
	m.player.visible = false

	m.homeUi = m.top.findNode("HomeUI")

	m.busyspinner = m.top.findNode("Spinner")
	m.busyspinner.poster.observeField("loadStatus", "showspinner")

	ipAddress = m.top.findNode("ipAddress")
	networkInterface = m.top.findNode("networkInterface")
	ipData = util.GetFirstLocalIPAddress()
	ipAddress.text = ipData.value
	networkInterface.text = ipData.key


	' 1. Find your UI elements if you need to update them later
	' m.statusLabel = m.top.findNode("StatusLabel")

	' 2. Create the Task node
	m.tcpTask = CreateObject("roSGNode", "TcpListenerTask")

	' 3. Set the port (optional, as it has a default in the XML)
	m.tcpTask.port = 46899

	' 4. Observe fields if you want the Task to send data back to the UI
	' m.tcpTask.observeField("receivedMessage", "onMessageReceived")

	' 5. Start the thread
	m.tcpTask.control = "RUN"
	#if logging
	print "TCP Task Thread Started..."
	#end if
	m.tcpTask.observeField("payload", "onPayloadReceived")

	m.top.setFocus(true)
end sub

sub onPayloadReceived()
	commanddata = m.tcpTask.payload
	if commanddata <> invalid
		opcode = commanddata.opcode
		payload = commanddata.payload

		if opcode = 1
			# if logging
			print "Play request for: "; payload.url
			# end if
			m.player.visible = true
			m.homeUi.visible = false

			' videoPlayer = m.top.findNode("videoElement")
			' Set content and start playback
			m.player.content = buildContentNodeForVideo({
				url: payload.url,
				mime: payload.container,
				time: payload.time
			})
			m.player.visible = true
			m.player.control = VideoControls.play

			m.player.setFocus(true)
		end if
	end if
end sub

sub showspinner()
	if(m.busyspinner.poster.loadStatus = "ready")
		m.busyspinner.visible = true
	end if
end sub

sub onVisibleChange()
	if m.top.visible = true
		m.tcpTask.control = "RUN"
	else
		m.tcpTask.control = "STOP"
	end if
end sub

function onKeyEvent(key as string, press as boolean) as boolean
	#if logging
		print "in FCastScene onKeyEvent ";key;" "; press
	#end if

	videoPlayer = m.player

	if press
	    if key = "back"
	        if videoPlayer.visible = true then
	            videoPlayer.control = "stop"
	            videoPlayer.visible = false
				m.homeUi.visible = true
	            m.top.setFocus(true)
	            return true ' We handled the event
	        end if
	    end if
	end if
end function




' Maps the mimetype from standard MIME strings to the strings roku expects
sub mapMimeType(mime as string) as string
	' see StreamFormat section of https://developer.roku.com/en-ca/docs/developer-program/getting-started/architecture/content-metadata.md#example-of-configuring-a-dash-stream-with-widevine-drm

	' application/octet-stream can be for .mov, .mkv, .hls
	mimeMap = {
		"video/mp4": "mp4"
		"video/x-m4v": "mp4"' (mp4 will also accept .m4v files)
		"video/quicktime": "mp4" '.mov  (mp4 will also accept .mov files)
		"video/x-quicktime": "mp4" '.mov  (mp4 will also accept .mov files)

		"application/x-mpegURL": "hls"

		"application/dash+xml": "dash"

		"video/x-matroska": "mkv"
		"audio/x-matroska": "mkv"
		"audio/matroska": "mkv"
		"video/matroska": "mkv"
		"application/x-matroska": "mkv"

		"audio/mpeg": "mp3"

		' these seem too likely to not be supported
		' "image/mov": "mp4" '.mov  (mp4 will also accept .mov files)
		' "image/x-quicktime": "mp4" '.mov  (mp4 will also accept .mov files)
		' "video/matroska-3d": "mkv"
	}
	convertedType = mimeMap[mime]
	if convertedType <> invalid then
		return convertedType
	else
		return ""
	end if
end sub


' Create a content node suitable for passing into a video element
sub buildContentNodeForVideo(castContent as object) as object
	' Create the content node required by the Video player
	videoContent = CreateObject("roSGNode", "ContentNode")
	mimetype = mapMimeType(castContent.mime)
	if mimetype = "" then
		print "Invalid Mime type provided: " + castContent.mime + " Could not map to a roku streamformat"
		return invalid
	end if

	if castContent.url <> invalid then
		videoContent.url = castContent.url
	else
		#if debug
			print "cast content provided an invalid URL field"
			print castContent
		#end if
	end if


	videoContent.StreamFormat = mimetype

	' if castContent.start <> invalid then
	' 	videoContent.PlayStart=
	' endif
	return videoContent
end sub
